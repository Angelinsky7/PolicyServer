using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using PolicyServer1.EntityFramework.Storage.Interfaces;

namespace PolicyServer1.EntityFramework.Storage {
    public static class DbContextExtensions {

        /// <summary>Detaches all the entites of a given type.</summary>
        /// <typeparam name="TEntity">The type of the entity.</typeparam>
        /// <param name="context">The context.</param>
        /// <autogeneratedoc />
        public static void MarkEntitesAsDetached<TEntity>(this IPolicyDbContext context) where TEntity : class {
            //IEnumerable<EntityEntry<TEntity>> entities = context.ChangeTracker.Entries<TEntity>().ToList();

            //foreach (EntityEntry<TEntity> item in entities) {
            //    item.State = EntityState.Detached;
            //}

            context.ChangeTracker.Entries<TEntity>().ToList().ForEach(p => p.State = EntityState.Detached);
        }

        /// <summary>Detaches all the entites of a given type.</summary>
        /// <typeparam name="TEntity">The type of the entity.</typeparam>
        /// <param name="context">The context.</param>
        /// <autogeneratedoc />
        public static void MarkEntitesAsUnchanged<TEntity>(this IPolicyDbContext context) where TEntity : class {
            //IEnumerable<EntityEntry<TEntity>> entities = context.ChangeTracker.Entries<TEntity>().ToList();

            //foreach (EntityEntry<TEntity> item in entities) {
            //    item.State = EntityState.Unchanged;
            //}

            context.ChangeTracker.Entries<TEntity>().ToList().ForEach(p => p.State = EntityState.Unchanged);
        }

        public static async Task CheckExistingAndRemoveAsync<TEntity>(this IPolicyDbContext context, IEqualityComparer<TEntity> comparer = null) where TEntity : class {
            IEnumerable<TEntity> existingEntities = await context.Set<TEntity>().AsNoTracking().ToListAsync();
            IEnumerable<EntityEntry<TEntity>> entitiesToAdd = context.GetEntryFromChangeTrackerWithMulitpleTriesHack<TEntity>(existingEntities.Count());

            foreach (EntityEntry<TEntity> item in entitiesToAdd) {
                if (comparer != null ? existingEntities.Contains(item.Entity, comparer) : existingEntities.Contains(item.Entity)) {
                    item.State = EntityState.Unchanged;
                }
            }
        }

        public static async Task CheckExistingAndRemoveAsync<TEntity>(this IPolicyDbContext context, Func<TEntity, TEntity, Boolean> comparer) where TEntity : class {
            IEnumerable<TEntity> existingEntities = await context.Set<TEntity>().AsNoTracking().ToListAsync();
            IEnumerable<EntityEntry<TEntity>> entitiesToAdd = context.GetEntryFromChangeTrackerWithMulitpleTriesHack<TEntity>(existingEntities.Count());

            foreach (EntityEntry<TEntity> item in entitiesToAdd) {
                if (existingEntities.Any(p => comparer(p, item.Entity))) {
                    item.State = EntityState.Unchanged;
                }
            }
        }

        /// <summary>Checks the existing entities of  a given type and mark as unchanged all the ones that already exist asynchronous.</summary>
        /// <typeparam name="TEntity">The type of the entity.</typeparam>
        /// <param name="context">The context.</param>
        /// <param name="comparer">The comparer.</param>
        /// <autogeneratedoc />
        public static async Task MarkEntitesAsUnchangedWithHackAsync<TEntity>(this IPolicyDbContext context/*, Func<TEntity, TEntity, Boolean> comparer*/) where TEntity : class {
            IEnumerable<TEntity> existingEntities = await context.Set<TEntity>().AsNoTracking().ToListAsync();
            context.GetEntryFromChangeTrackerWithMulitpleTriesHack<TEntity>(existingEntities.Count()).ToList().ForEach(p => p.State = EntityState.Unchanged);
        }

        /// <summary>Checks the existing entities of  a given type and mark as unchanged all the ones that already exist asynchronous.</summary>
        /// <typeparam name="TEntity">The type of the entity.</typeparam>
        /// <param name="context">The context.</param>
        /// <param name="comparer">The comparer.</param>
        /// <autogeneratedoc />
        public static async Task MarkEntitesAsUnchangedWithHackAsync<TEntity>(this IPolicyDbContext context, Func<TEntity, TEntity, Boolean> comparer) where TEntity : class {
            IEnumerable<TEntity> existingEntities = await context.Set<TEntity>().AsNoTracking().ToListAsync();
            IEnumerable<EntityEntry<TEntity>> entitiesToAdd = context.GetEntryFromChangeTrackerWithMulitpleTriesHack<TEntity>(existingEntities.Count());

            foreach (EntityEntry<TEntity> item in entitiesToAdd) {
                if (existingEntities.Any(p => comparer(p, item.Entity))) {
                    item.State = EntityState.Unchanged;
                }
            }
        }

        private static IEnumerable<EntityEntry<TEntity>> GetEntryFromChangeTrackerWithMulitpleTriesHack<TEntity>(this IPolicyDbContext context, Int32 maxNumberOfTries) where TEntity : class {
            IEnumerable<EntityEntry<TEntity>> result = null;

            for (Int32 numberOfTries = 0; numberOfTries < maxNumberOfTries; ++numberOfTries) {
                try {
                    result = context.ChangeTracker.Entries<TEntity>().ToList();
                } catch { }
                if (result != null) { break; }
            }

            if (result == null) {
                result = context.ChangeTracker.Entries<TEntity>().ToList();
            }

            return result;
        }
    }
}
